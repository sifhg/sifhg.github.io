(()=>{"use strict";var e,r,t,o,a={254:(e,r,t)=>{t.a(e,(async(e,r)=>{try{const e={dark:{r:.8,g:.2,b:.2,a:1},light:{r:1,g:.6,b:.6,a:1},white:{r:1,g:1,b:1,a:1}},t=4,o=document.getElementById("codelab-canvas");if(!navigator.gpu){const e=document.getElementsByTagName("canvas");for(const r of e)r.outerHTML='<p style="color: red">Your browser does not support WebGPU. <br> I suggest you use <i>Chrome v. 113</i> or check the browser compatibility at <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API#browser_compatibility">https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API#browser_compatibility</a>.</p>';throw new Error("WebGPU not supported on this browser.")}const a=await navigator.gpu.requestAdapter();if(!a)throw new Error("No appropriate GPUAdapter found.");const n=await a.requestDevice(),i=o.getContext("webgpu"),s=navigator.gpu.getPreferredCanvasFormat();i?.configure({device:n,format:s});const u=new Float32Array([-.8,-.8,.8,-.8,.8,.8,-.8,-.8,.8,.8,-.8,.8]),c=n.createBuffer({label:"Cell vertices",size:u.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});n.queue.writeBuffer(c,0,u);const f={arrayStride:8,attributes:[{format:"float32x2",offset:0,shaderLocation:0}]},l=new Float32Array([t,t]),p=n.createBuffer({label:"Grid Uniforms",size:l.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});n.queue.writeBuffer(p,0,l);const d=n.createShaderModule({label:"Cell shader",code:"\n    @group(0) @binding(0) var<uniform> grid: vec2f;\n\n    @vertex\n    fn vertexMain(@location(0) pos: vec2f) ->\n        @builtin(position) vec4f {\n        return vec4(pos, 0, 1);\n    }\n\n    @fragment\n    fn fragmentMain() -> @location(0) vec4f {\n        return vec4f(1, 1, 1, 1);\n    }\n    "}),b=n.createRenderPipeline({label:"Cell pipeline",layout:"auto",vertex:{module:d,entryPoint:"vertexMain",buffers:[f]},fragment:{module:d,entryPoint:"fragmentMain",targets:[{format:s}]}}),g=(n.createBindGroup({label:"Cell renderer bind group",layout:b.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:p}}]}),n.createCommandEncoder()),m=g.beginRenderPass({colorAttachments:[{view:i.getCurrentTexture().createView(),loadOp:"clear",clearValue:e.dark,storeOp:"store"}]});m.setPipeline(b),m.setVertexBuffer(0,c),m.draw(u.length/2),m.end(),n.queue.submit([g.finish()]),r()}catch(e){r(e)}}),1)}},n={};function i(e){var r=n[e];if(void 0!==r)return r.exports;var t=n[e]={exports:{}};return a[e](t,t.exports,i),t.exports}e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",r="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",t="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",o=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},i.a=(a,n,i)=>{var s;i&&((s=[]).d=-1);var u,c,f,l=new Set,p=a.exports,d=new Promise(((e,r)=>{f=r,c=e}));d[r]=p,d[e]=e=>(s&&e(s),l.forEach(e),d.catch((e=>{}))),a.exports=d,n((a=>{var n;u=(a=>a.map((a=>{if(null!==a&&"object"==typeof a){if(a[e])return a;if(a.then){var n=[];n.d=0,a.then((e=>{i[r]=e,o(n)}),(e=>{i[t]=e,o(n)}));var i={};return i[e]=e=>e(n),i}}var s={};return s[e]=e=>{},s[r]=a,s})))(a);var i=()=>u.map((e=>{if(e[t])throw e[t];return e[r]})),c=new Promise((r=>{(n=()=>r(i)).r=0;var t=e=>e!==s&&!l.has(e)&&(l.add(e),e&&!e.d&&(n.r++,e.push(n)));u.map((r=>r[e](t)))}));return n.r?c:i()}),(e=>(e?f(d[t]=e):c(p),o(s)))),s&&s.d<0&&(s.d=0)},i(254)})();